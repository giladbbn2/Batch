using Batch.Worker;
using Newtonsoft.Json;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Batch.Foreman
{
    public abstract class ForemanBase : IDisposable
    {
        public string PathToSettingsFile;

        private WorkerActivator WorkerActivator;
        private ForemanConfiguration Config;

        private Dictionary<int, Task> tasks;    // workers
        private Dictionary<int, int> nodesWorkers;
        private Dictionary<int, BlockingCollection<object>> queues;

        // helper dicts
        private Dictionary<string, int> workerNameToId;
        private Dictionary<string, int> nodeNameToId;
        private Dictionary<string, int> queueNameToId;

        private int workerCounter;
        private int nodeCounter;
        private int queuesCounter;
        private int connectionsCounter;

        private bool disposed;

        public ForemanBase()
        {
            Config = new ForemanConfiguration();
        }

        public ForemanBase(string PathToSettingsFile)
        {
            this.PathToSettingsFile = PathToSettingsFile;
            Config = new ForemanConfiguration();
        }

        public void LoadSettingsFile(string PathToSettingsFile)
        {
            this.PathToSettingsFile = PathToSettingsFile;
            LoadSettingsFile();
        }

        public void LoadSettingsFile()
        {
            if (disposed)
                return;

            if (PathToSettingsFile == null)
                throw new ArgumentNullException("PathToSettingsFile");

            if (!File.Exists(PathToSettingsFile))
                throw new FileNotFoundException(PathToSettingsFile);

            WorkerActivator = new WorkerActivator();

            workerCounter = 0;
            nodeCounter = 0;
            queuesCounter = 0;
            connectionsCounter = 0;

            string settings = File.ReadAllText(PathToSettingsFile);

            try
            {
                Config = JsonConvert.DeserializeObject<ForemanConfiguration>(settings);
            }
            catch (Exception ex)
            {
                throw new Exception("Can't parse config file: " + PathToSettingsFile);
            }

            // Register workers
            if (Config.workers == null || Config.workers.Count == 0)
                throw new ArgumentException("No workers in config file");

            workerNameToId = new Dictionary<string, int>(Config.workers.Count);
            foreach (var worker in Config.workers)
            {
                worker.id = workerCounter;
                RegisterWorker(workerCounter, worker.name, worker.className);
                workerCounter++;
            }

            // Register nodes
            if (Config.nodes == null || Config.nodes.Count == 0)
                throw new ArgumentException("No nodes in config file");

            nodeNameToId = new Dictionary<string, int>(Config.nodes.Count);
            foreach (var node in Config.nodes)
            {
                node.id = nodeCounter;

                string workerName = node.worker;

                if (!workerNameToId.ContainsKey(workerName))
                    throw new ArgumentException("The worker name '" + workerName + "' in nodes section is not defined in workers section");

                int workerId = workerNameToId[workerName];
                
                RegisterNode(nodeCounter, node.name, workerId);
                nodeCounter++;
            }

            // Register queues
            if (Config.queues == null || Config.queues.Count == 0)
                throw new ArgumentException("No queues in config file");

            queues = new Dictionary<int, BlockingCollection<object>>(Config.queues.Count);
            queueNameToId = new Dictionary<string, int>(Config.queues.Count);
            foreach (var queue in Config.queues)
            {
                queue.id = queuesCounter;
                RegisterQueue(queuesCounter, queue.name, queue.bufferLimit);
                queuesCounter++;
            }


            // dispose of helper dicts
        }

        private void RegisterWorker(int WorkerId, string WorkerName, string WorkerClassNameWithNamespace)
        {
            if (disposed)
                return;

            WorkerActivator.RegisterWorkerActivator(WorkerId, WorkerClassNameWithNamespace);
            workerNameToId.Add(WorkerName, WorkerId);
            // add task?
        }

        private void RegisterNode(int NodeId, string NodeName, int WorkerId)
        {
            if (disposed)
                return;


        }

        private void RegisterQueue(int QueueId, string QueueName, int BufferLimit)
        {
            if (disposed)
                return;

            if (BufferLimit == 0)
                queues.Add(QueueId, new BlockingCollection<object>());
            else
                queues.Add(QueueId, new BlockingCollection<object>(BufferLimit));

            queueNameToId.Add(QueueName, QueueId);
        }

        public void Dispose()
        {
            disposed = true;
        }

    }
}
